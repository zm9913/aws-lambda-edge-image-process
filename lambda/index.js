const AwsPromise = require('./util/AwsPromise');
const ImageLib = require('./util/ImageLib');
const QueryParser = require('./util/QueryParser');
const Md5 = require('./util/Md5');

l = m => console.log(m);
let formats = {
    '@jpg': '@1080w_1920h_0e_1l_95q.jpg',
    '@icon': '@512w_512h_0e_1l_95q.jpg',
    '@thumb': '@800w_800h_0e_1l_95q.jpg',
    '@mini': '@500w_500h_0e_1l_95q.jpg',
    '@png': '@1080w_1920h_0e_1l_95q.png'
}

exports.handler = async function (event, context, callback) {
    event = event['Records'][0];
    l('----------- HANDLER ------------');
    l(JSON.stringify(event));
    let cf = event['cf'];
    let ret = await handleOriginResponse(cf['request'], cf['response']);

    let response = ret ? ret : cf['response'];
    // Support client cache
    if (response['status'] && response['status'] < 400) {
        response['headers']['cache-control'] = [{'key': 'Cache-Control', 'value': 'max-age=86400'}]
    }
    // l(`response: ${JSON.stringify(response)}`)
    callback(null, response);
};

const getBucketNameFromCFRequest = (request) => {
    let domain;
    try {
        domain = request.origin.s3.domainName;
    } catch (e) {
        return false;
    }
    if (!domain.includes('.amazonaws.com')) {
        return false;
    }
    return domain.split('.')[0];
};

const parseRequestPolicy = (uri) => {
    let format = uri.substring(uri.lastIndexOf('@'));
    if (formats[format]) {
        return QueryParser.parseUri(uri.replace(format, formats[format]));
    }
    return false;
};

const handleOriginResponse = async (request, response) => {
    if (response['status'] < 400 || response['status'] > 599) {
        return false;
    }
    // Fetch bucket name
    let bucketName = getBucketNameFromCFRequest(request);
    if (bucketName === false) {
        return false;
    }
    l(`bucket: ${bucketName}`)

    // Parse request params
    let requestPolicy = parseRequestPolicy(request['uri']);
    if (requestPolicy === false) {
        return false;
    }
    l(`requestPolicy: ${JSON.stringify(requestPolicy)}`)

    let rawObjectKey = requestPolicy.originImagePath;
    while (rawObjectKey.charAt(0) === '/') { // Remove all / of left
        rawObjectKey = rawObjectKey.substr(1);
    }
    let saveObjKey = request['uri'];
    while (saveObjKey.charAt(0) === '/') { // Remove all / of left
        saveObjKey = saveObjKey.substr(1);
    }

    let contentType = getContentTypeByExt(requestPolicy.targetFormatExt);

    l('resize image start')
    let buffer = await resizeImage(bucketName, rawObjectKey, requestPolicy.targetFormatExt, requestPolicy.filterMap);
    l('resize image end')
    if (!buffer) {
        l('resize image failed')
        return false;
    }

    // async upload to s3
    l('upload start')
    uploadToS3(bucketName, saveObjKey, buffer, contentType).then(ret => {
        l(`upload ret: ${JSON.stringify(ret)}`)
        l('upload end')
    });

    return generateResponse(response, buffer, contentType)
};

const resizeImage = async (bucketName, objectKey, targetFormatExt, option) => {
    l('get image start')
    let image = await AwsPromise.getObj({
        Bucket: bucketName,
        Key: objectKey
    });


    if (!image) {
        l('get image failed')
        return false;
    }
    l('get image succeed!')

    return await ImageLib.adjustImage(image, targetFormatExt, option);
};


const uploadToS3 = async (bucketName, objectKey, buffer, contentType) => {
    // Upload the generated object to s3
    return await AwsPromise.putObj({
        Bucket: bucketName,
        Key: objectKey,
        Body: buffer,
        ContentType: contentType,
        Tagging: 'createByLambda=1',
    });
}

const generateResponse = (response, buffer, contentType) => {
    response['status'] = '200'
    //Json cannot serialize binary picture files, so first force-code them with base64 into text files that json thinks can be serialized, and then reverse-code at the browser end
    response['body'] = buffer.toString('base64');
    response['bodyEncoding'] = 'base64'
    response['headers']['content-type'] = [{'key': 'Content-Type', 'value': contentType}]
    response['headers']['content-encoding'] = [{'key': 'Content-Encoding', 'value': 'base64'}]
    response['headers']['content-length'] = [{'key': 'Content-Length', 'value': response['body'].length + ''}]
    response['headers']['etag'] = [{'key': 'Etag', 'value': Md5(response['body'])}] // With it, Ensure that cdn will response 304 to client if content not modify

    response['statusDescription'] = 'Generated by CloudFront Original Response Function'

    return response
};

const getContentTypeByExt = (ext) => {
    const map = {
        jpg: 'image/jpeg',
        jpeg: 'image/jpeg',
        png: 'image/png',
        webp: 'image/webp',
    };
    return map[ext];
};
